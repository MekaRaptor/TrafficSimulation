package src.core;

import java.util.List;
import java.util.Random;
import java.util.ArrayList;
import java.util.concurrent.atomic.AtomicBoolean;

public class Vehicle extends Thread {
    private final String id;
    private int position;
    private boolean active;
    private final List<Road> route;
    private final List<TrafficLight> lights;
    private final List<Intersection> intersections;
    private static final int MAX_RETRY_COUNT = 3;
    private static final Random random = new Random();
    private Road currentRoad;
    private double progress = 0.0;
    private long totalWaitTime = 0;
    private long waitStartTime = 0;
    private double speed;
    private VehicleType type;
    
    // Yeni ger√ßek√ßi sistem i√ßin eklenenler
    private CityMap.Zone startZone;
    private CityMap.Zone endZone;
    private CityMap.Zone currentZone;
    private List<Road> alternativeRoute = new ArrayList<>();
    private boolean useAlternativeRoute = false;
    private long lastRouteUpdate = System.currentTimeMillis();
    private int routeRecalculationCount = 0;
    private double fuelLevel = 100.0; // Yakƒ±t seviyesi
    private String purpose = ""; // Seyahat amacƒ±
    
    public enum VehicleType {
        CAR(1.0, "≈ûahsi Ara√ß"),
        TRUCK(0.7, "Kamyon"),
        MOTORCYCLE(1.3, "Motosiklet"),
        BUS(0.8, "Otob√ºs"),
        TAXI(1.1, "Taksi"),
        DELIVERY(0.9, "Kargo Aracƒ±");
        
        private final double speedFactor;
        private final String displayName;
        
        VehicleType(double speedFactor, String displayName) {
            this.speedFactor = speedFactor;
            this.displayName = displayName;
        }
        
        public double getSpeedFactor() {
            return speedFactor;
        }
        
        public String getDisplayName() {
            return displayName;
        }
        
        public static VehicleType getRandomType() {
            VehicleType[] types = VehicleType.values();
            return types[random.nextInt(types.length)];
        }
        
        // Zone'a g√∂re ara√ß t√ºr√º daƒüƒ±lƒ±mƒ±
        public static VehicleType getRandomTypeForZone(CityMap.ZoneType zoneType) {
            switch (zoneType) {
                case RESIDENTIAL:
                    // Konut b√∂lgelerinde daha √ßok ≈üahsi ara√ß
                    if (random.nextDouble() < 0.7) return CAR;
                    if (random.nextDouble() < 0.9) return MOTORCYCLE;
                    return BUS;
                    
                case COMMERCIAL:
                    // Ticaret b√∂lgelerinde karƒ±≈üƒ±k
                    if (random.nextDouble() < 0.4) return CAR;
                    if (random.nextDouble() < 0.6) return TAXI;
                    if (random.nextDouble() < 0.8) return DELIVERY;
                    return TRUCK;
                    
                case INDUSTRIAL:
                    // Sanayi b√∂lgelerinde aƒüƒ±r ara√ßlar
                    if (random.nextDouble() < 0.5) return TRUCK;
                    if (random.nextDouble() < 0.7) return DELIVERY;
                    return CAR;
                    
                case DOWNTOWN:
                    // ≈ûehir merkezinde taksi ve otob√ºs
                    if (random.nextDouble() < 0.3) return TAXI;
                    if (random.nextDouble() < 0.5) return BUS;
                    if (random.nextDouble() < 0.8) return CAR;
                    return MOTORCYCLE;
                    
                default:
                    return getRandomType();
            }
        }
    }

    public Vehicle(String id, List<Road> route, List<TrafficLight> lights, List<Intersection> intersections) {
        this.id = id;
        this.route = route;
        this.lights = lights;
        this.intersections = intersections;
        this.position = 0;
        this.active = true;
        this.type = VehicleType.getRandomType();
        this.speed = type.getSpeedFactor() * (0.8 + random.nextDouble() * 0.4); // Random speed variation
        
        // Zone tabanlƒ± ara√ß t√ºr√º ve ama√ß belirleme
        if (startZone != null) {
            this.type = VehicleType.getRandomTypeForZone(startZone.getType());
            this.purpose = generatePurpose();
        }
        
        if (!route.isEmpty()) {
            this.currentRoad = route.get(0);
        }
    }

    @Override
    public void run() {
        System.out.println("üöó Vehicle " + id + " (" + type.getDisplayName() + ") starting journey: " + 
                         getZoneName(startZone) + " ‚Üí " + getZoneName(endZone) + " (" + purpose + ")");
        
        for (int i = 0; i < route.size() && active; i++) {
            Road currentRoad = route.get(i);
            TrafficLight currentLight = null;
            Intersection currentIntersection = null;
            
            // Trafik ƒ±≈üƒ±ƒüƒ± ve kav≈üak bulma
            if (i < lights.size()) currentLight = lights.get(i);
            if (i < intersections.size()) currentIntersection = intersections.get(i);
            
            this.currentRoad = currentRoad;
            this.progress = 0.0;
            
            // Zone g√ºncelleme
            updateCurrentZone();
            
            // Dinamik rota kontrol√º
            if (shouldRecalculateRoute()) {
                recalculateRoute(i);
            }
            
            int retryCount = 0;
            boolean success = false;
            
            while (!success && retryCount < MAX_RETRY_COUNT && active) {
                try {
                    waitStartTime = System.currentTimeMillis();
                    success = tryToMoveThrough(currentRoad, currentLight, currentIntersection);
                    if (!success) {
                        retryCount++;
                        // Add random wait time to prevent deadlocks
                        Thread.sleep(random.nextInt(1000) + 500);
                        
                        if (retryCount == MAX_RETRY_COUNT) {
                            // Try alternative route or turn back
                            System.out.println("Vehicle " + id + " failed to proceed after " + MAX_RETRY_COUNT + " attempts");
                            handleFailure(i);
                        }
                    }
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    break;
                }
            }
            
            // Yakƒ±t t√ºketimi
            consumeFuel();
        }
        
        System.out.println("‚úÖ Vehicle " + id + " completed journey to " + getZoneName(endZone) + 
                         " (Total wait: " + (totalWaitTime / 1000) + "s, Fuel: " + String.format("%.1f%%", fuelLevel) + ")");
    }

    private boolean tryToMoveThrough(Road road, TrafficLight light, Intersection intersection) throws InterruptedException {
        // G√ú√áL√ú Trafik ƒ±≈üƒ±ƒüƒ± kontrol√º
        if (light != null) {
            System.out.println("üö¶ Vehicle " + id + " checking traffic light for road " + road.getId());
            waitStartTime = System.currentTimeMillis();
            
            int lightWaitCount = 0;
            final int MAX_LIGHT_WAIT = 50; // Maksimum 5 saniye bekle (50 * 100ms)
            
            while (active && light.getTrafficLightState() != TrafficLight.State.GREEN && lightWaitCount < MAX_LIGHT_WAIT) {
                TrafficLight.State currentState = light.getTrafficLightState();
                System.out.println("üî¥ Vehicle " + id + " waiting for GREEN light, current: " + currentState);
                Thread.sleep(100);
                lightWaitCount++;
            }
            
            if (lightWaitCount >= MAX_LIGHT_WAIT) {
                System.out.println("‚ö†Ô∏è Vehicle " + id + " timed out waiting for traffic light");
                totalWaitTime += System.currentTimeMillis() - waitStartTime;
                return false;
            }
            
            totalWaitTime += System.currentTimeMillis() - waitStartTime;
            System.out.println("üü¢ Vehicle " + id + " got GREEN light, proceeding");
        }
        
        // Yola giri≈ü denemesi
        if (!road.addVehicle(this)) {
            System.out.println("üö´ Vehicle " + id + " cannot enter road " + road.getId() + " (full)");
            return false;
        }
        
        System.out.println("‚úÖ Vehicle " + id + " entered road " + road.getId());
        
        // Kav≈üak kontrol√º (varsa)
        if (intersection != null) {
            waitStartTime = System.currentTimeMillis();
            if (!intersection.enter(id)) {
                road.removeVehicle(this);
                totalWaitTime += System.currentTimeMillis() - waitStartTime;
                System.out.println("üö´ Vehicle " + id + " cannot enter intersection " + intersection.getId());
                return false;
            }
            totalWaitTime += System.currentTimeMillis() - waitStartTime;
            System.out.println("‚úÖ Vehicle " + id + " entered intersection " + intersection.getId());
        }
        
        // Yolda hareket (burada progress takip edilir)
        moveOnRoad(road);
        
        // Kav≈üaktan √ßƒ±kƒ±≈ü
        if (intersection != null) {
            intersection.exit(id);
            System.out.println("‚úÖ Vehicle " + id + " exited intersection " + intersection.getId());
        }
        
        road.removeVehicle(this);
        System.out.println("‚úÖ Vehicle " + id + " exited road " + road.getId());
        
        return true;
    }

    private void handleFailure(int currentRouteIndex) {
        // Geli≈ümi≈ü hata y√∂netimi
        System.out.println("üö® Vehicle " + id + " handling failure at route index " + currentRouteIndex);
        
        if (alternativeRoute.isEmpty()) {
            // Alternatif rota bulunamadƒ±, geri d√∂n
            if (currentRouteIndex > 0) {
                System.out.println("Vehicle " + id + " is returning to previous road");
                position--;
                if (currentRouteIndex - 1 < route.size()) {
                    currentRoad = route.get(currentRouteIndex - 1);
                }
            } else {
                System.out.println("Vehicle " + id + " cancelling route");
                active = false;
            }
        } else {
            // Alternatif rotaya ge√ß
            useAlternativeRoute = true;
            System.out.println("Vehicle " + id + " switching to alternative route");
        }
    }

    private void moveOnRoad(Road road) {
        position++;
        
        // Yol t√ºr√ºne ve trafik durumuna g√∂re hƒ±z ayarlamasƒ±
        double baseSpeed = speed;
        
        // Yol t√ºr√º fakt√∂r√º
        if (road.getRoadType() != null) {
            switch (road.getRoadType()) {
                case HIGHWAY:
                    baseSpeed *= 1.5; // Otoyolda hƒ±zlƒ±
                    break;
                case MAIN_ROAD:
                    baseSpeed *= 1.2;
                    break;
                case RESIDENTIAL_STREET:
                    baseSpeed *= 0.7; // Konut sokaƒüƒ±nda yava≈ü
                    break;
            }
        }
        
        // Trafik sƒ±kƒ±≈üƒ±klƒ±ƒüƒ± fakt√∂r√º
        double congestion = road.getCongestionLevel();
        double congestionFactor = 1.0 - (congestion * 0.8);
        baseSpeed *= congestionFactor;
        
        // Zone fakt√∂r√º
        if (currentZone != null) {
            baseSpeed *= currentZone.getType().getTrafficDensityFactor();
        }
        
        // Ara√ß t√ºr√º fakt√∂r√º
        if (type == VehicleType.MOTORCYCLE && congestion > 0.5) {
            baseSpeed *= 1.3; // Motosikletler trafikte daha hƒ±zlƒ±
        }
        
        // D√úZELTME: Hareket sim√ºlasyonu - yolda kalma garantisi
        int steps = 50; // Daha hassas hareket i√ßin step sayƒ±sƒ±nƒ± artƒ±rdƒ±k
        double stepDelay = 100 / Math.max(0.1, baseSpeed);
        
        for (int i = 0; i < steps && active; i++) {
            try {
                // Progress yol sƒ±nƒ±rlarƒ± i√ßinde kalmalƒ± (0.0 - 1.0)
                progress = Math.min(1.0, Math.max(0.0, i / (double)steps));
                
                // Mevcut road deƒüi≈ümemeli
                if (currentRoad == null || !currentRoad.equals(road)) {
                    System.out.println("‚ö†Ô∏è Vehicle " + id + " road reference lost, stopping movement");
                    break;
                }
                
                Thread.sleep((long)stepDelay);
                
                // Rastgele duraklamalar (ger√ßek√ßi hareket i√ßin) - azaltƒ±ldƒ±
                if (random.nextDouble() < 0.02) { // %2'ye d√º≈ü√ºr√ºld√º
                    Thread.sleep(random.nextInt(100) + 50);
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                break;
            }
        }
        
        progress = 1.0; // Yol tamamlandƒ±
        
        System.out.println("‚úÖ Vehicle " + id + " completed road " + road.getId() + 
                         " (" + road.getRoadType().getDisplayName() + ")" + 
                         " Speed: " + String.format("%.1f", baseSpeed) + 
                         " Congestion: " + String.format("%.1f%%", congestion * 100));
    }
    
    private void updateCurrentZone() {
        // Mevcut yola g√∂re zone g√ºncelle (basit versiyon)
        if (currentRoad != null && startZone != null && endZone != null) {
            double routeProgress = (double) position / route.size();
            if (routeProgress < 0.3) {
                currentZone = startZone;
            } else if (routeProgress > 0.7) {
                currentZone = endZone;
            } else {
                // Ara b√∂lgede, rastgele zone se√ß veya aynƒ± kalsƒ±n
            }
        }
    }
    
    private boolean shouldRecalculateRoute() {
        // 30 saniyede bir rota kontrol√º
        return (System.currentTimeMillis() - lastRouteUpdate > 30000) && 
               (routeRecalculationCount < 3); // Maksimum 3 kez yeniden hesapla
    }
    
    private void recalculateRoute(int currentIndex) {
        // Basit rota yeniden hesaplama
        if (currentRoad != null && currentRoad.getCongestionLevel() > 0.7) {
            System.out.println("üîÑ Vehicle " + id + " is recalculating route due to heavy traffic");
            routeRecalculationCount++;
            lastRouteUpdate = System.currentTimeMillis();
            
            // TODO: Ger√ßek A* pathfinding algoritmasƒ± eklenecek
            // ≈ûimdilik sadece mesaj g√∂ster
        }
    }
    
    private void consumeFuel() {
        // Yakƒ±t t√ºketimi sim√ºlasyonu
        double consumption = 0.5; // Temel t√ºketim
        
        if (currentRoad != null) {
            // Yol t√ºr√ºne g√∂re t√ºketim
            switch (currentRoad.getRoadType()) {
                case HIGHWAY:
                    consumption *= 0.8; // Otoyolda verimli
                    break;
                case RESIDENTIAL_STREET:
                    consumption *= 1.2; // Dur-kalk fazla yakƒ±t
                    break;
            }
            
            // Sƒ±kƒ±≈üƒ±klƒ±kta daha fazla yakƒ±t
            consumption *= (1.0 + currentRoad.getCongestionLevel() * 0.5);
        }
        
        // Ara√ß t√ºr√ºne g√∂re t√ºketim
        switch (type) {
            case TRUCK:
                consumption *= 2.0;
                break;
            case BUS:
                consumption *= 1.8;
                break;
            case MOTORCYCLE:
                consumption *= 0.5;
                break;
        }
        
        fuelLevel = Math.max(0, fuelLevel - consumption);
        
        if (fuelLevel < 10) {
            System.out.println("‚õΩ Vehicle " + id + " is low on fuel (" + String.format("%.1f%%", fuelLevel) + ")");
        }
    }
    
    private String generatePurpose() {
        if (startZone == null || endZone == null) return "Seyahat";
        
        CityMap.ZoneType startType = startZone.getType();
        CityMap.ZoneType endType = endZone.getType();
        
        if (startType == CityMap.ZoneType.RESIDENTIAL && endType == CityMap.ZoneType.COMMERCIAL) {
            return "Alƒ±≈üveri≈ü";
        } else if (startType == CityMap.ZoneType.RESIDENTIAL && endType == CityMap.ZoneType.DOWNTOWN) {
            return "ƒ∞≈ü";
        } else if (endType == CityMap.ZoneType.INDUSTRIAL) {
            return "Kargo/ƒ∞≈ü";
        } else if (endType == CityMap.ZoneType.PARK) {
            return "Rekreasyon";
        } else if (startType == endType) {
            return "Yerel Seyahat";
        }
        
        return "Genel Seyahat";
    }
    
    private String getZoneName(CityMap.Zone zone) {
        return zone != null ? zone.getType().getDisplayName() + " (" + zone.getId() + ")" : "Bilinmeyen";
    }

    // Getter metodlarƒ±
    public String getVehicleId() {
        return id;
    }

    public boolean isActive() {
        return active;
    }

    public Road getCurrentRoad() {
        return currentRoad;
    }

    public double getProgress() {
        return progress;
    }

    public long getTotalWaitTime() {
        return totalWaitTime;
    }
    
    public VehicleType getVehicleType() {
        return type;
    }
    
    public double getSpeed() {
        return speed;
    }

    public void stopVehicle() {
        active = false;
        // Thread'i interrupt et ki d√∂ng√ºden √ßƒ±ksƒ±n
        this.interrupt();
    }
    
    // Yeni getter/setter metodlarƒ±
    public void setStartZone(CityMap.Zone startZone) {
        this.startZone = startZone;
        if (startZone != null) {
            this.type = VehicleType.getRandomTypeForZone(startZone.getType());
            this.purpose = generatePurpose();
        }
    }
    
    public void setEndZone(CityMap.Zone endZone) {
        this.endZone = endZone;
        this.purpose = generatePurpose();
    }
    
    public CityMap.Zone getStartZone() {
        return startZone;
    }
    
    public CityMap.Zone getEndZone() {
        return endZone;
    }
    
    public CityMap.Zone getCurrentZone() {
        return currentZone;
    }
    
    public String getPurpose() {
        return purpose;
    }
    
    public double getFuelLevel() {
        return fuelLevel;
    }
    
    public int getRouteRecalculationCount() {
        return routeRecalculationCount;
    }
    
    @Override
    public String toString() {
        return String.format("Vehicle[%s, %s, %s‚Üí%s, Fuel: %.1f%%, Wait: %ds]", 
                           id, type.getDisplayName(), 
                           getZoneName(startZone), getZoneName(endZone),
                           fuelLevel, totalWaitTime / 1000);
    }
}
